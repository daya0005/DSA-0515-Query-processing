# -*- coding: utf-8 -*-
"""Untitled5.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15muMkdzrVH5Ds6d_eDgQ8fOrYlaQoNEq
"""

import pandas as pd
import numpy as np
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.decomposition import TruncatedSVD
from sklearn.model_selection import train_test_split

# Load Data from CSV files
user_interactions_df = pd.read_csv('/content/user_interactions_optimized.csv')
product_info_df = pd.read_csv('/content/product_info_optimized.csv')

# Handling duplicate entries by averaging ratings for each unique (user_id, product_id) pair
user_interactions_df = user_interactions_df.groupby(['user_id', 'product_id']).agg({'rating': 'mean'}).reset_index()

# Data Preprocessing
# Merge data for content-based filtering
merged_data = pd.merge(user_interactions_df, product_info_df, on="product_id")

# Encode categorical data (e.g., category) for product attributes
product_info_encoded = pd.get_dummies(product_info_df, columns=['category'])

# 1. Collaborative Filtering Model (Matrix Factorization with SVD)
user_product_matrix = user_interactions_df.pivot(index='user_id', columns='product_id', values='rating').fillna(0)
n_components = min(50, user_product_matrix.shape[1])
svd = TruncatedSVD(n_components=n_components)
latent_matrix = svd.fit_transform(user_product_matrix)
user_similarity = cosine_similarity(latent_matrix)
user_similarity_df = pd.DataFrame(user_similarity, index=user_product_matrix.index, columns=user_product_matrix.index)

def recommend_collaborative(user_id, num_recommendations=5):
    similar_users = user_similarity_df[user_id].sort_values(ascending=False).index[1:num_recommendations+1]
    similar_users_ratings = user_product_matrix.loc[similar_users].mean(axis=0)
    recommended_products = similar_users_ratings[~user_product_matrix.loc[user_id].isna()].sort_values(ascending=False)
    return recommended_products.head(num_recommendations).index.tolist()

# 2. Content-Based Filtering Model
product_features = product_info_encoded.drop(['product_id', 'name', 'price'], axis=1)
product_similarity = cosine_similarity(product_features)
product_similarity_df = pd.DataFrame(product_similarity, index=product_info_encoded['product_id'], columns=product_info_encoded['product_id'])

def recommend_content_based(product_id, num_recommendations=5):
    similar_products = product_similarity_df[product_id].sort_values(ascending=False).index[1:num_recommendations+1]
    return similar_products.tolist()

# 3. Hybrid Recommendation System with Improved Performance
def recommend_hybrid(user_id, product_id=None, num_recommendations=5):
    collaborative_recs = recommend_collaborative(user_id, num_recommendations * 2)

    if product_id:
        content_recs = recommend_content_based(product_id, num_recommendations * 2)
        combined_recs = list(set(collaborative_recs) | set(content_recs))
        hybrid_recs = list(set(collaborative_recs).intersection(content_recs))

        if len(hybrid_recs) < num_recommendations:
            hybrid_recs += [item for item in combined_recs if item not in hybrid_recs][:num_recommendations - len(hybrid_recs)]

        return hybrid_recs[:num_recommendations]

    return collaborative_recs[:num_recommendations]

# 4. Evaluation Function
def evaluate_model(recommendation_function, test_user_data, use_num_recommendations=True):
    train, test = train_test_split(test_user_data, test_size=0.2, random_state=42)
    precisions, recalls = [], []

    for user_id, group in test.groupby('user_id'):
        true_products = set(group['product_id'])

        if use_num_recommendations:
            recommended_products = set(recommendation_function(user_id, num_recommendations=5))
        else:
            recommended_products = set(recommendation_function(user_id))

        precision = len(true_products.intersection(recommended_products)) / len(recommended_products) if recommended_products else 0
        recall = len(true_products.intersection(recommended_products)) / len(true_products) if true_products else 0

        precisions.append(precision)
        recalls.append(recall)

    avg_precision = np.mean(precisions)
    avg_recall = np.mean(recalls)

    return avg_precision, avg_recall

# Run Evaluation for each recommendation model
collab_precision, collab_recall = evaluate_model(recommend_collaborative, user_interactions_df)
content_precision, content_recall = evaluate_model(
    lambda user_id: recommend_content_based(product_info_df['product_id'].iloc[0]),
    user_interactions_df,
    use_num_recommendations=False
)
hybrid_precision, hybrid_recall = evaluate_model(recommend_hybrid, user_interactions_df)

# Display Results
print(f"- Collaborative Filtering:\n  - *Average Precision*: {collab_precision:.2f}\n  - *Average Recall*: {collab_recall:.2f}\n")
print(f"- Content-Based Filtering:\n  - *Average Precision*: {content_precision:.2f}\n  - *Average Recall*: {content_recall:.2f}\n")
print(f"- Hybrid Recommendation System:\n  - *Average Precision*: {hybrid_precision:.2f}\n  - *Average Recall*: {hybrid_recall:.2f}\n")